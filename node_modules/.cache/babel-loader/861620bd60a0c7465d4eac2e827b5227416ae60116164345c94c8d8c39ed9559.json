{"ast":null,"code":"var _jsxFileName = \"/Users/nilaypatel/Desktop/stufff/coding/current projects/nilay_website/website 3 (sorting visulizer)/Sorting-Visualizer-Tutorial-master/src/SortingVisualizer/SortingVisualizer.jsx\";\nimport React from 'react';\nimport { getMergeSortAnimations } from '../sortingAlgorithms/sortingAlgorithms.js';\nimport './SortingVisualizer.css';\n\n// Change this value for the speed of the animations.\n// const ANIMATION_SPEED_MS = 1;\nconst ANIMATION_SPEED_MS = 1500;\n\n// Change this value for the number of bars (value) in the array.\n// const NUMBER_OF_ARRAY_BARS = 310; \nconst NUMBER_OF_ARRAY_BARS = 10;\n\n// This is the main color of the array bars.\nconst PRIMARY_COLOR = 'blue';\n\n// This is the color of array bars that are being compared throughout the animations.\nconst SECONDARY_COLOR = 'red';\n\n// The code below is the beginning of a React component called SortingVisualizer. This component is intended to create a visual representation of sorting algorithms using bars that represent values to be sorted.\n\n// export default class SortingVisualizer extends React.Component: This line exports the SortingVisualizer class as the default export from the module. The class extends React.Component, meaning it's a React component that can be used in your application.\nexport default class SortingVisualizer extends React.Component {\n  // constructor(props): The constructor is a special method that runs when an instance of the class is created. It initializes the state and other properties of the component.\n  constructor(props) {\n    // super(props): This line calls the constructor of the parent class (React.Component). It's necessary to call this when you're extending a class in JavaScript.\n    super(props);\n    // this.state = { array: [] };: Here, the initial state of the component is defined. The state is an object that holds data that can change over time and affect the rendering of the component. In this case, the state has a property called array, which will store the values to be sorted.\n    this.state = {\n      array: []\n    };\n  }\n\n  // componentDidMount(): This is a lifecycle method in React that runs after the component is inserted into the DOM. It's a good place to perform actions that need to happen once the component is ready. In this case, it generates a random array using the generateRandomArray method and updates the component's state with the generated array.\n  componentDidMount() {\n    this.resetArray();\n  }\n  resetArray() {\n    const array = [];\n    // for (let i = 0; i < NUMBER_OF_ARRAY_BARS; i++) {\n    //   array.push(randomIntFromInterval(5, 730));\n    // }\n    array.push(121);\n    array.push(201);\n    array.push(363);\n    array.push(105);\n    array.push(510);\n    array.push(647);\n    array.push(14);\n    array.push(464);\n    array.push(36);\n    array.push(501);\n    this.setState({\n      array\n    });\n  }\n  async mergeSort() {\n    //     Inside your sorting methods, update the array state after each comparison and swap, so that the changes are reflected in the visualization.\n    const animations = getMergeSortAnimations(this.state.array); // steps of the Merge Sort algorithm\n    for (let i = 0; i < animations.length; i++) {\n      const arrayBars = document.getElementsByClassName('array-bar');\n      const isColorChange = i % 3 !== 2; // checks if it is a color change or height change\n      if (isColorChange) {\n        setTimeout(() => {\n          // creating delay before changing background color for visual animation\n          const [barOneIdx, barTwoIdx] = animations[i];\n          const barOneStyle = arrayBars[barOneIdx].style;\n          const barTwoStyle = arrayBars[barTwoIdx].style;\n          const color = i % 3 === 0 ? SECONDARY_COLOR : PRIMARY_COLOR;\n          barOneStyle.backgroundColor = color;\n          barTwoStyle.backgroundColor = color;\n        }, i * ANIMATION_SPEED_MS);\n      } else {\n        setTimeout(() => {\n          const [barOneIdx, newHeight] = animations[i];\n          const barOneStyle = arrayBars[barOneIdx].style;\n          barOneStyle.height = `${newHeight}px`;\n        }, i * ANIMATION_SPEED_MS);\n      }\n      if (i % 4 == 0) {\n        setTimeout(() => {\n          // creating delay before changing background color for visual animation\n          const [barOneIdx, barTwoIdx] = animations[i];\n          const barOneStyle = arrayBars[barOneIdx].style;\n          const barTwoStyle = arrayBars[barTwoIdx].style;\n          const color = \"yellow\";\n          barOneStyle.backgroundColor = color;\n          barTwoStyle.backgroundColor = color;\n        }, i * ANIMATION_SPEED_MS);\n      } else if (i % 4 == 3) {\n        setTimeout(() => {\n          const [barOneIdx, newHeight] = animations[i];\n          const barOneStyle = arrayBars[barOneIdx].style;\n          barOneStyle.height = `${newHeight}px`;\n        }, i * ANIMATION_SPEED_MS);\n      } else {}\n    }\n  }\n  quickSort() {\n    // We leave it as an exercise to the viewer of this code to implement this method.\n  }\n  heapSort() {\n    // We leave it as an exercise to the viewer of this code to implement this method.\n  }\n  bubbleSort() {\n    // We leave it as an exercise to the viewer of this code to implement this method.\n  }\n\n  // NOTE: This method will only work if your sorting algorithms actually return\n  // the sorted arrays; if they return the animations (as they currently do), then\n  // this method will be broken.\n  testSortingAlgorithms() {\n    for (let i = 0; i < 100; i++) {\n      const array = [];\n      const length = randomIntFromInterval(1, 1000);\n      for (let i = 0; i < length; i++) {\n        array.push(randomIntFromInterval(-1000, 1000));\n      }\n\n      // array: This refers to the array of values that you have in your React component's state. It's the array you're intending to sort.\n\n      // .slice(): The slice() method is used to create a shallow copy of the original array. This is done to ensure that the original array remains unchanged, as the subsequent sort() operation modifies the array in place.\n\n      // .sort((a, b) => a - b): This is the sorting operation itself. The sort() method sorts the elements of the array in place and returns the sorted array. The comparison function (a, b) => a - b is used as an argument to the sort() method. This function determines the sorting order by subtracting b from a.\n\n      // If the result of a - b is negative, a will be placed before b in the sorted array.\n      // If the result is positive, b will be placed before a in the sorted array.\n      // If the result is zero, the order of a and b remains unchanged.\n      const javaScriptSortedArray = array.slice().sort((a, b) => a - b);\n      const mergeSortedArray = getMergeSortAnimations(array.slice());\n      console.log(arraysAreEqual(javaScriptSortedArray, mergeSortedArray));\n    }\n  }\n\n  //   Rendering the Array:\n  // You can create a render method to display the array as bars on the screen. Each value in the array will be represented by a colored bar with a height corresponding to its value.\n\n  // render(): The render method is a required method in React components. It returns the JSX (HTML-like syntax) that defines the component's UI.\n  render() {\n    const {\n      array\n    } = this.state;\n    return /*#__PURE__*/React.createElement(\"div\", {\n      className: \"array-container\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 148,\n        columnNumber: 7\n      }\n    }, array.map((value, idx) => /*#__PURE__*/React.createElement(\"div\", {\n      className: \"array-bar\"\n      // key={index}: Each element in a list should have a unique key prop. Here, the index of the element in the array is used as the key.\n      ,\n      key: idx\n      // style={{ height: ${value}px }}: This inline style sets the height of each bar based on the value, creating the visual representation of the values to be sorted.\n      ,\n      style: {\n        backgroundColor: PRIMARY_COLOR,\n        height: `${value}px`\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 151,\n        columnNumber: 11\n      }\n    }, value)), /*#__PURE__*/React.createElement(\"button\", {\n      onClick: () => this.resetArray(),\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 158,\n        columnNumber: 9\n      }\n    }, \"Generate New Array\"), /*#__PURE__*/React.createElement(\"button\", {\n      onClick: () => this.mergeSort(),\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 159,\n        columnNumber: 9\n      }\n    }, \"Merge Sort\"), /*#__PURE__*/React.createElement(\"button\", {\n      onClick: () => this.quickSort(),\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 160,\n        columnNumber: 9\n      }\n    }, \"Quick Sort\"), /*#__PURE__*/React.createElement(\"button\", {\n      onClick: () => this.heapSort(),\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 161,\n        columnNumber: 9\n      }\n    }, \"Heap Sort\"), /*#__PURE__*/React.createElement(\"button\", {\n      onClick: () => this.bubbleSort(),\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 162,\n        columnNumber: 9\n      }\n    }, \"Bubble Sort\"), /*#__PURE__*/React.createElement(\"button\", {\n      onClick: () => this.testSortingAlgorithms(),\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 163,\n        columnNumber: 9\n      }\n    }, \"Test Sorting Algorithms (BROKEN)\"));\n  }\n}\n\n// From https://stackoverflow.com/questions/4959975/generate-random-number-between-two-numbers-in-javascript\nfunction randomIntFromInterval(min, max) {\n  // min and max included\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\nfunction arraysAreEqual(arrayOne, arrayTwo) {\n  if (arrayOne.length !== arrayTwo.length) return false;\n  for (let i = 0; i < arrayOne.length; i++) {\n    if (arrayOne[i] !== arrayTwo[i]) {\n      return false;\n    }\n  }\n  return true;\n}","map":{"version":3,"names":["React","getMergeSortAnimations","ANIMATION_SPEED_MS","NUMBER_OF_ARRAY_BARS","PRIMARY_COLOR","SECONDARY_COLOR","SortingVisualizer","Component","constructor","props","state","array","componentDidMount","resetArray","push","setState","mergeSort","animations","i","length","arrayBars","document","getElementsByClassName","isColorChange","setTimeout","barOneIdx","barTwoIdx","barOneStyle","style","barTwoStyle","color","backgroundColor","newHeight","height","quickSort","heapSort","bubbleSort","testSortingAlgorithms","randomIntFromInterval","javaScriptSortedArray","slice","sort","a","b","mergeSortedArray","console","log","arraysAreEqual","render","createElement","className","__self","__source","fileName","_jsxFileName","lineNumber","columnNumber","map","value","idx","key","onClick","min","max","Math","floor","random","arrayOne","arrayTwo"],"sources":["/Users/nilaypatel/Desktop/stufff/coding/current projects/nilay_website/website 3 (sorting visulizer)/Sorting-Visualizer-Tutorial-master/src/SortingVisualizer/SortingVisualizer.jsx"],"sourcesContent":["import React from 'react';\nimport {getMergeSortAnimations} from '../sortingAlgorithms/sortingAlgorithms.js';\nimport './SortingVisualizer.css';\n\n// Change this value for the speed of the animations.\n// const ANIMATION_SPEED_MS = 1;\nconst ANIMATION_SPEED_MS = 1500;\n\n// Change this value for the number of bars (value) in the array.\n// const NUMBER_OF_ARRAY_BARS = 310; \nconst NUMBER_OF_ARRAY_BARS = 10;\n\n// This is the main color of the array bars.\nconst PRIMARY_COLOR = 'blue';\n\n// This is the color of array bars that are being compared throughout the animations.\nconst SECONDARY_COLOR = 'red';\n\n\n// The code below is the beginning of a React component called SortingVisualizer. This component is intended to create a visual representation of sorting algorithms using bars that represent values to be sorted.\n\n// export default class SortingVisualizer extends React.Component: This line exports the SortingVisualizer class as the default export from the module. The class extends React.Component, meaning it's a React component that can be used in your application.\nexport default class SortingVisualizer extends React.Component {\n  // constructor(props): The constructor is a special method that runs when an instance of the class is created. It initializes the state and other properties of the component.\n  constructor(props) {\n    // super(props): This line calls the constructor of the parent class (React.Component). It's necessary to call this when you're extending a class in JavaScript.\n    super(props);\n    // this.state = { array: [] };: Here, the initial state of the component is defined. The state is an object that holds data that can change over time and affect the rendering of the component. In this case, the state has a property called array, which will store the values to be sorted.\n    this.state = {\n      array: []\n    };\n  }\n\n  // componentDidMount(): This is a lifecycle method in React that runs after the component is inserted into the DOM. It's a good place to perform actions that need to happen once the component is ready. In this case, it generates a random array using the generateRandomArray method and updates the component's state with the generated array.\n  componentDidMount() {\n    this.resetArray();\n  }\n\n  resetArray() {\n    const array = [];\n    // for (let i = 0; i < NUMBER_OF_ARRAY_BARS; i++) {\n    //   array.push(randomIntFromInterval(5, 730));\n    // }\n    array.push(121);\n    array.push(201);\n    array.push(363);\n    array.push(105);\n    array.push(510);\n    array.push(647);\n    array.push(14);\n    array.push(464);\n    array.push(36);\n    array.push(501);\n    this.setState({array});\n  }\n\n  async mergeSort() {\n//     Inside your sorting methods, update the array state after each comparison and swap, so that the changes are reflected in the visualization.\n    const animations = getMergeSortAnimations(this.state.array); // steps of the Merge Sort algorithm\n    for (let i = 0; i < animations.length; i++) {\n      const arrayBars = document.getElementsByClassName('array-bar');\n      const isColorChange = i % 3 !== 2; // checks if it is a color change or height change\n      if (isColorChange) {\n        setTimeout(() => { // creating delay before changing background color for visual animation\n          const [barOneIdx, barTwoIdx] = animations[i];\n          const barOneStyle = arrayBars[barOneIdx].style;\n          const barTwoStyle = arrayBars[barTwoIdx].style;\n          const color = i % 3 === 0 ? SECONDARY_COLOR : PRIMARY_COLOR;\n          barOneStyle.backgroundColor = color;\n          barTwoStyle.backgroundColor = color;\n        }, i * ANIMATION_SPEED_MS);\n      } else {\n        setTimeout(() => {\n          const [barOneIdx, newHeight] = animations[i];\n          const barOneStyle = arrayBars[barOneIdx].style;\n          barOneStyle.height = `${newHeight}px`;\n        }, i * ANIMATION_SPEED_MS);\n      }\n\n      if(i % 4 == 0){\n        setTimeout(() => { // creating delay before changing background color for visual animation\n          const [barOneIdx, barTwoIdx] = animations[i];\n          const barOneStyle = arrayBars[barOneIdx].style;\n          const barTwoStyle = arrayBars[barTwoIdx].style;\n          const color = \"yellow\";\n          barOneStyle.backgroundColor = color;\n          barTwoStyle.backgroundColor = color;\n        }, i * ANIMATION_SPEED_MS);\n      }else if(i % 4 == 3){\n        setTimeout(() => {\n          const [barOneIdx, newHeight] = animations[i];\n          const barOneStyle = arrayBars[barOneIdx].style;\n          barOneStyle.height = `${newHeight}px`;\n        }, i * ANIMATION_SPEED_MS);\n      }else{\n        \n      }\n    }\n  }\n\n  quickSort() {\n    // We leave it as an exercise to the viewer of this code to implement this method.\n  }\n\n  heapSort() {\n    // We leave it as an exercise to the viewer of this code to implement this method.\n  }\n\n  bubbleSort() {\n    // We leave it as an exercise to the viewer of this code to implement this method.\n  }\n\n  // NOTE: This method will only work if your sorting algorithms actually return\n  // the sorted arrays; if they return the animations (as they currently do), then\n  // this method will be broken.\n  testSortingAlgorithms() {\n    for (let i = 0; i < 100; i++) {\n      const array = [];\n      const length = randomIntFromInterval(1, 1000);\n      for (let i = 0; i < length; i++) {\n        array.push(randomIntFromInterval(-1000, 1000));\n      }\n\n// array: This refers to the array of values that you have in your React component's state. It's the array you're intending to sort.\n\n// .slice(): The slice() method is used to create a shallow copy of the original array. This is done to ensure that the original array remains unchanged, as the subsequent sort() operation modifies the array in place.\n\n// .sort((a, b) => a - b): This is the sorting operation itself. The sort() method sorts the elements of the array in place and returns the sorted array. The comparison function (a, b) => a - b is used as an argument to the sort() method. This function determines the sorting order by subtracting b from a.\n\n// If the result of a - b is negative, a will be placed before b in the sorted array.\n// If the result is positive, b will be placed before a in the sorted array.\n// If the result is zero, the order of a and b remains unchanged.\n      const javaScriptSortedArray = array.slice().sort((a, b) => a - b);\n\n      const mergeSortedArray = getMergeSortAnimations(array.slice());\n      console.log(arraysAreEqual(javaScriptSortedArray, mergeSortedArray));\n    }\n  }\n\n//   Rendering the Array:\n// You can create a render method to display the array as bars on the screen. Each value in the array will be represented by a colored bar with a height corresponding to its value.\n\n// render(): The render method is a required method in React components. It returns the JSX (HTML-like syntax) that defines the component's UI.\n  render() {\n    const {array} = this.state;\n\n    return (\n      <div className=\"array-container\">\n        {/* {array.map((value, index) => ( ... ))}: This uses the map function to iterate over each value in the array state. It creates a <div> element for each value and sets its height based on the value, creating the bar visualization effect. */}\n        {array.map((value, idx) => (\n          <div\n            className=\"array-bar\"\n            // key={index}: Each element in a list should have a unique key prop. Here, the index of the element in the array is used as the key.\n            key={idx}\n            // style={{ height: ${value}px }}: This inline style sets the height of each bar based on the value, creating the visual representation of the values to be sorted.\n            style={{ backgroundColor: PRIMARY_COLOR, height: `${value}px`}}>{value}</div>\n        ))}\n        <button onClick={() => this.resetArray()}>Generate New Array</button>\n        <button onClick={() => this.mergeSort()}>Merge Sort</button>\n        <button onClick={() => this.quickSort()}>Quick Sort</button>\n        <button onClick={() => this.heapSort()}>Heap Sort</button>\n        <button onClick={() => this.bubbleSort()}>Bubble Sort</button>\n        <button onClick={() => this.testSortingAlgorithms()}>\n          Test Sorting Algorithms (BROKEN)\n        </button>\n      </div>\n    );\n  }\n}\n\n// From https://stackoverflow.com/questions/4959975/generate-random-number-between-two-numbers-in-javascript\nfunction randomIntFromInterval(min, max) {\n  // min and max included\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\n\nfunction arraysAreEqual(arrayOne, arrayTwo) {\n  if (arrayOne.length !== arrayTwo.length) return false;\n  for (let i = 0; i < arrayOne.length; i++) {\n    if (arrayOne[i] !== arrayTwo[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}